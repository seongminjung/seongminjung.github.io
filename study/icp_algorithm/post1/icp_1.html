<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>ICP 1: Known Data Association & SVD</title>
    <meta name="description" content="Seongmin Jung's personal website" />
    <meta name="keywords" content="Seongmin Jung, Robotics" />
    <meta name="author" content="Seongmin Jung" />
    <meta name="language" content="English" />
    <link rel="shortcut icon" href="/favicon.png" />

    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-LL44K1WZ0G"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag() {
        dataLayer.push(arguments);
      }
      gtag("js", new Date());
      gtag("config", "G-LL44K1WZ0G");
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}
      });
    </script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-MML-AM_CHTML" async></script>

    <!-- Load an icon library to show a hamburger menu (bars) on small screens -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css" />
    <!-- import css -->
    <link rel="stylesheet" href="/css/index.css" />
    <!-- import js -->
    <script src="/js/script.js" defer></script>
  </head>

  <body>
    <header>
      <img class="cover" src="/asset/cover.jpg" alt="Seongmin Jung" />
      <h1 class="title"><a href="/index.html">Seongmin Jung</a></h1>
      <nav class="nav">
        <a href="/index.html">Home</a>
        <a href="/projects.html">Projects</a>
        <a href="/study.html" class="bold">Study</a>
        <i id="nav-toggle" class="nav-toggle fa fa-bars" onclick="toggleNav()"></i>
      </nav>
    </header>

    <div id="nav-modal-bg" onclick="toggleNav()"></div>
    <nav id="nav-modal">
      <a href="/index.html">Home</a>
      <a href="/projects.html">Projects</a>
      <a href="/study.html" class="bold">Study</a>
    </nav>

    <main>
      <div class="container">
        <section id="post">
          <h1>ICP & Point Cloud Registration - Part 1: Known Data Association & SVD</h1>
          <p class="date">Posted on <time datetime="2023-09-10">September 10, 2023</time></p>
          <div class="post-body">
            <h2>To begin with</h2>
            <p>
              This is a summary of the first part of the ICP & Point Cloud Registration series by Prof. Cyrill
              Stachniss. Lecture slides and videos are available on the
              <a href="https://www.ipb.uni-bonn.de/index.html%3Fp=4424.html" target="_blank">course website</a> or his
              <a
                href="https://youtube.com/playlist?list=PLgnQpQtFTOGQh_J16IMwDlji18SWQ2PZ6&feature=shared"
                target="_blank"
                >YouTube channel</a
              >. Through this series, we will learn the basics of the Iterative Closest Point (ICP) algorithm and build
              the code from scratch.
            </p>
            <h2>What is ICP?</h2>
            <p>
              Iterative Closest Point (ICP) is an algorithm to register two point clouds. Point cloud is a set of points
              in 3D space, and registration is a process of aligning two point clouds. What this algorithm does is
              better explained with a picture.
            </p>
            <img src="/study/icp_algorithm/post1/img1.png" alt="What is ICP?" />
            <p>
              The <span class="color-red">red markers</span> indicate the first 2D Lidar scan and the
              <span class="color-green">green markers</span> indicate the second. Imagine we are in a self-driving car,
              and the Lidar sensor is scanning the environment. Intuitively, we understand that the car is moving
              forward because the dots appear to be moving backward. But here is the question for the car:
              <b>Where exactly is the car located, and how far has it actually moved?</b> These are fundamental question
              in the field of self-driving car and mobile robotics, since precise localization is tightly related with
              safety, efficiency, and accuracy.
            </p>

            <h3>In a nutshell</h3>
            <p>
              ICP is a simple and strong algorithm for estimating the transformation between the two point clouds, which
              can be directly used to derive the past trajectory of the car or robot. The algorithm is as follows:
            </p>
            <ol>
              <li>Find the closest point in the second point cloud for each point in the first point cloud.</li>
              <li>Compute the transformation that aligns the first point cloud to the second point cloud.</li>
              <li>Apply the transformation to the first point cloud.</li>
              <li>Repeat 1-3 until convergence.</li>
            </ol>
            <p>
              Through this series of posts, we will go through each step in detail. In this post, we will focus on
              computing the transformation given the perfectly matching pairs of points (correspondences).
            </p>

            <h2>Building from scratch</h2>
            <h3>Software setup</h3>
            <p>
              We will use <b>ROS noetic</b> with <b>C++</b> language. Detailed setup tutorial can be found in
              <a href="/study/ros1_robotics/post1/join_the_ros1_revolution.html" target="_blank">my previous posts</a>.
            </p>

            <h3>Dataset</h3>
            <p>
              To keep things straightforward, we will utilize a basic handmade dataset for this post. We will create two
              point clouds, each with a small number of points. It has been proven that a
              <b>one-shot optimal solution exists</b> for this alignment problem, provided the
              <b>correct correspondences</b> are identified. Let's see how it works.
            </p>
            <p>img</p>
            <p>
              In our setup, the <span class="color-red">red dots</span> depict the initial point cloud, while the
              <span class="color-green">green dots</span> indicate the second point cloud. Our goal is to align these
              two sets: we'll use the red dots as our reference and carefully adjust the position of the green dots
              until they align perfectly with the red ones.
            </p>

            <h3>Key Terms and Parameters</h3>
            <p>
              Before we dive into the algorithm, let's define some key terms and parameters that will be used throughout
              this series. We will use the following notations:
            </p>

            <h4>Key terms</h4>
            <ul>
              <li>
                <b>Correspondence</b>: A pair of points that are known to be the same. For the sake of simplicity, we
                artificially designate two points as corresponding if they share the same index, $i$. $x_i$ and $y_i$
                are the same point in different point cloud.
              </li>
              <li>
                <b>Registration</b>: The process of finding the rotation matrix $\mathbf{R}$ and translation vector
                $\mathbf{t}$ that aligns the two point clouds $\mathbf{X}$ and $\mathbf{Y}$.
              </li>
            </ul>

            <h4>Parameters</h4>
            <ul>
              <li><b>Reference (first) point cloud</b>: $\mathbf{Y} = \{y_1, y_2, \cdots, y_n\}$</li>
              <li><b>Incoming (second) point cloud</b>: $\mathbf{X} = \{x_1, x_2, \cdots, x_n\}$</li>
              <li><b>Rotation matrix and translation vector</b>: $\mathbf{R}$ and $\mathbf{t}$</li>
              <li><b>Transformed point cloud</b>: $\bar{\mathbf{X}} = \{\bar{x}_1, \bar{x}_2, \cdots, \bar{x}_n\}$</li>
            </ul>
          </div>
        </section>
      </div>
    </main>

    <footer>
      <p>&copy; 2024 Seongmin Jung<br />Designed and developed by Seongmin Jung</p>
    </footer>
  </body>
</html>
